# 🌐 EmojiLang - A Language Translator Using Flex, Bison, and C

EmojiLang is a language translator designed using **Flex, Bison, and C** that processes emoji-based syntax. It recognizes and validates integer and floating-point values represented by emojis and performs basic type validation. This project demonstrates the use of **lexical analysis** and **parsing** to build a simple interpreter.

---

## 🚀 **Features**

✅ Supports emoji-based syntax:
- `🔢` → Represents the beginning of a statement (number declaration).  
- `📦` → Represents an **integer** type.  
- `🎁` → Represents a **float** type.  
- `;` → Terminates a statement.

✅ Handles multiple statements separated by semicolons.  
✅ Performs type checking:
- Ensures **integer** types only accept integer values.  
- Ensures **float** types only accept floating-point values.  
- Provides detailed error messages in case of mismatched types or missing semicolons.  

✅ Displays clear output messages:
- **Valid: INTEGER value.**  
- **Valid: FLOAT value.**  
- **Error: Expecting INTEGER but entered FLOAT value.**  
- **Error: Expecting FLOAT but entered INTEGER value.**  
- **Error: Missing semicolon at the end.**

---

## 🛠️ **How It Works**

EmojiLang uses **lexical analysis** and **parsing** to process emoji-based syntax.

### 🔥 **Lexical Analysis (lexer.l)**  
The lexer scans the input and tokenizes it based on the following patterns:
- `🔢` → `NUMBER` token.  
- `📦` → `INTEGER` token.  
- `🎁` → `FLOAT` token.  
- Numeric patterns:
  - `[0-9]+` → `INT_VAL` token.  
  - `[0-9]+"."[0-9]+` → `FLOAT_VAL` token.  
- Semicolon (`;`) → `SEMICOLON` token.  
- Ignores whitespace (`[ \t\n]+`).  
- Prints an **Unknown Token** error if an unrecognized character is encountered.

### ⚙️ **Parsing (parser.y)**  
The parser processes the token stream generated by the lexer and applies the following rules:
- **Program Structure:**  
  - Supports multiple statements.  
  - Each statement follows the pattern:  
    ```
    🔢 TYPE VALUE ;
    ```

- **Type Validation:**  
  - For `📦` → Only integer values are valid.  
  - For `🎁` → Only float values are valid.  
  - Performs proper type conversion and validation.

---

## 📂 **File Structure**

```
📁 EmojiLang
 ├── lexer.l               # Lexer definition (Flex file)
 ├── parser.y              # Parser definition (Bison file)
 ├── input.txt             # Sample input file for testing
 ├── Makefile (optional)   # For easy compilation and execution
 ├── emoji_lang.exe        # Compiled executable
 ├── README.md             # Documentation
```

---

## ⚡ **Usage Instructions**

### 1️⃣ **Install Required Tools**
Ensure you have the following installed:
- **Flex**
- **Bison**
- **GCC**

For Linux:
```bash
sudo apt install flex bison gcc
```

For Windows:
- Install **WinFlexBison** and add it to your system path.

---

### 2️⃣ **Compilation & Execution**

Run the following commands to compile and execute EmojiLang:

```bash
# Lex and Bison Compilation
win_flex lexer.l  
win_bison -d parser.y  
gcc parser.tab.c lex.yy.c -o emoji_lang.exe  

# Execute the program with an input file
emoji_lang.exe < input.txt
```

---

### 3️⃣ **Sample Inputs**

✅ **Valid Examples:**
```
🔢 📦 123;
🔢 🎁 12.34;
```
Output:
```
Valid: INTEGER value.  
Valid: FLOAT value.  
```

❌ **Invalid Examples:**
```
🔢 📦 12.34;
```
Output:
```
Error: Expecting INTEGER but entered FLOAT value.
```

```
🔢 🎁 10;
```
Output:
```
Error: Expecting FLOAT but entered INTEGER value.
```

---

## 🔧 **Customization**
- Add new emojis and rules by modifying `lexer.l` and `parser.y`.  
- Enhance with more data types, operations, or complex syntax.  

---

## 📌 **Contributing**
Feel free to contribute to this project by submitting issues or pull requests. Let's make EmojiLang even more fun and robust!  

---

✅ Enjoy coding with **EmojiLang**! 😁
